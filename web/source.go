/*
Copyright 2017 Caicloud Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package web

import (
	"context"
	"fmt"
	"io"
	"mime/multipart"
	"reflect"
	"strings"

	"github.com/caicloud/nirvana/definition"
)

// ParameterGenerator is used to generate object for a parameter.
type ParameterGenerator interface {
	// Source returns the source generated by current generator.
	Source() definition.Source
	// Validate validates whether defaultValue and target type is valid.
	Validate(name string, defaultValue interface{}, target reflect.Type) error
	// Generate generates an object by data from value container.
	Generate(ctx context.Context, vc ValueContainer, name string, target reflect.Type) (interface{}, error)
}

var generators = map[definition.Source]ParameterGenerator{}

// ParameterGeneratorFor gets a parameter generator for specified source.
func ParameterGeneratorFor(source definition.Source) ParameterGenerator {
	return generators[source]
}

// RegisterParameterGenerator register a generator.
func RegisterParameterGenerator(generator ParameterGenerator) error {
	if _, ok := generators[generator.Source()]; ok {
		return fmt.Errorf("parameter generator of source %s has been registered", generator.Source())
	}
	generators[generator.Source()] = generator
	return nil
}

func assignable(defaultValue interface{}, target reflect.Type) error {
	if defaultValue == nil {
		return nil
	}
	value := reflect.ValueOf(defaultValue)
	if !value.Type().AssignableTo(target) {
		return fmt.Errorf("default value type %s can't assign to type %s", value.Type().String(), target.String())
	}
	return nil
}

func convertible(target reflect.Type) error {
	c := ConverterFor(target)
	if c == nil {
		return fmt.Errorf("type %s has no converter", target.String())
	}
	return nil
}

// PathParameterGenerator is used to generate object by value from path
type PathParameterGenerator struct{}

func (g *PathParameterGenerator) Source() definition.Source { return definition.Path }
func (g *PathParameterGenerator) Validate(name string, defaultValue interface{}, target reflect.Type) error {
	if err := assignable(defaultValue, target); err != nil {
		return err
	}
	if err := convertible(target); err != nil {
		return err
	}
	return nil
}
func (g *PathParameterGenerator) Generate(ctx context.Context, vc ValueContainer, name string, target reflect.Type) (interface{}, error) {
	data, ok := vc.Path(name)
	if !ok || len(data) <= 0 {
		return nil, nil
	}
	if converter := ConverterFor(target); converter != nil {
		return converter(ctx, []string{data})
	}
	return nil, nil
}

// QueryParameterGenerator is used to generate object by value from query string.
type QueryParameterGenerator struct{}

func (g *QueryParameterGenerator) Source() definition.Source { return definition.Query }
func (g *QueryParameterGenerator) Validate(name string, defaultValue interface{}, target reflect.Type) error {
	if err := assignable(defaultValue, target); err != nil {
		return err
	}
	if err := convertible(target); err != nil {
		return err
	}
	return nil
}
func (g *QueryParameterGenerator) Generate(ctx context.Context, vc ValueContainer, name string, target reflect.Type) (interface{}, error) {
	data, ok := vc.Query(name)
	if !ok || len(data) <= 0 {
		return nil, nil
	}
	if converter := ConverterFor(target); converter != nil {
		return converter(ctx, data)
	}
	return nil, nil
}

// HeaderParameterGenerator is used to generate object by value from request header.
type HeaderParameterGenerator struct{}

func (g *HeaderParameterGenerator) Source() definition.Source { return definition.Header }
func (g *HeaderParameterGenerator) Validate(name string, defaultValue interface{}, target reflect.Type) error {
	if err := assignable(defaultValue, target); err != nil {
		return err
	}
	if err := convertible(target); err != nil {
		return err
	}
	return nil
}

func (g *HeaderParameterGenerator) Generate(ctx context.Context, vc ValueContainer, name string, target reflect.Type) (interface{}, error) {
	data, ok := vc.Header(name)
	if !ok || len(data) <= 0 {
		return nil, nil
	}
	if converter := ConverterFor(target); converter != nil {
		return converter(ctx, data)
	}
	return nil, nil
}

// FormParameterGenerator is used to generate object by value from request form.
type FormParameterGenerator struct{}

func (g *FormParameterGenerator) Source() definition.Source { return definition.Form }
func (g *FormParameterGenerator) Validate(name string, defaultValue interface{}, target reflect.Type) error {
	if err := assignable(defaultValue, target); err != nil {
		return err
	}
	if err := convertible(target); err != nil {
		return err
	}
	return nil
}

func (g *FormParameterGenerator) Generate(ctx context.Context, vc ValueContainer, name string, target reflect.Type) (interface{}, error) {
	data, ok := vc.Form(name)
	if !ok || len(data) <= 0 {
		return nil, nil
	}
	if converter := ConverterFor(target); converter != nil {
		return converter(ctx, data)
	}
	return nil, nil
}

type repeatableCloserForFile struct {
	multipart.File
	closed bool
}

func (c *repeatableCloserForFile) Close() error {
	if c.closed {
		return nil
	}
	err := c.File.Close()
	if err != nil {
		return err
	}
	c.closed = true
	return nil
}

// FileParameterGenerator is used to generate file reader by value from request form file.
type FileParameterGenerator struct {
}

func (g *FileParameterGenerator) Source() definition.Source { return definition.File }
func (g *FileParameterGenerator) Validate(name string, defaultValue interface{}, target reflect.Type) error {
	err := assignable(defaultValue, target)
	if err != nil {
		return err
	}
	if !reflect.TypeOf((*multipart.File)(nil)).Elem().AssignableTo(target) {
		return fmt.Errorf("multipart.File can't assignable to %s", target.String())
	}
	return nil
}

func (g *FileParameterGenerator) Generate(ctx context.Context, vc ValueContainer, name string, target reflect.Type) (interface{}, error) {
	file, ok := vc.File(name)
	if !ok {
		return nil, nil
	}
	return repeatableCloserForFile{file, false}, nil
}

// BodyParameterGenerator is used to generate object or body reader by value from request body.
type BodyParameterGenerator struct{}

func (g *BodyParameterGenerator) Source() definition.Source { return definition.Body }
func (g *BodyParameterGenerator) Validate(name string, defaultValue interface{}, target reflect.Type) error {
	err := assignable(defaultValue, target)
	if err != nil {
		return err
	}
	kind := target.Kind()
	switch {
	case kind == reflect.Slice:
	case kind == reflect.Struct:
	case kind == reflect.Ptr && target.Elem().Kind() == reflect.Struct:
	case kind == reflect.Interface && reflect.TypeOf((*io.ReadCloser)(nil)).Elem().AssignableTo(target):
	default:
		return fmt.Errorf("%s is not a valid type for body", target.String())
	}
	return nil
}

type repeatableCloserForBody struct {
	io.ReadCloser
	closed bool
}

func (c *repeatableCloserForBody) Close() error {
	if c.closed {
		return nil
	}
	err := c.ReadCloser.Close()
	if err != nil {
		return err
	}
	c.closed = true
	return nil
}

func (g *BodyParameterGenerator) Generate(ctx context.Context, vc ValueContainer, name string, target reflect.Type) (interface{}, error) {
	reader, contentType, ok := vc.Body()
	if !ok {
		return nil, nil
	}
	kind := target.Kind()
	if kind == reflect.Interface && reflect.TypeOf((*io.ReadCloser)(nil)).Elem().AssignableTo(target) {
		return &repeatableCloserForBody{reader, false}, nil
	}
	consumer := ConsumerFor(contentType)
	if consumer == nil {
		return nil, nil
	}
	var value reflect.Value
	switch {
	case kind == reflect.Slice:
		value = reflect.MakeSlice(target, 0, 10)
	case kind == reflect.Struct:
		value = reflect.New(target)
	case kind == reflect.Ptr && target.Elem().Kind() == reflect.Struct:
		value = reflect.New(target.Elem())
	default:
		return nil, nil
	}
	if err := consumer.Consume(reader, value.Interface()); err != nil {
		return nil, err
	}
	if kind == reflect.Struct {
		return value.Elem().Interface(), nil
	}
	return value.Interface(), nil
}

// PrefabParameterGenerator is used to generate object by prefabs.
type PrefabParameterGenerator struct{}

func (g *PrefabParameterGenerator) Source() definition.Source { return definition.Prefab }
func (g *PrefabParameterGenerator) Validate(name string, defaultValue interface{}, target reflect.Type) error {
	err := assignable(defaultValue, target)
	if err != nil {
		return err
	}
	prefab := PrefabFor(name)
	if prefab == nil {
		return fmt.Errorf("no prefab named %s", name)
	}
	if !prefab.Type().AssignableTo(target) {
		return fmt.Errorf("prefab %s can't assign to type %s", prefab.Name(), target.String())
	}
	return nil
}

func (g *PrefabParameterGenerator) Generate(ctx context.Context, vc ValueContainer, name string, target reflect.Type) (interface{}, error) {
	prefab := PrefabFor(name)
	if prefab == nil {
		return nil, fmt.Errorf("no prefab named %s", name)
	}
	return prefab.Make(ctx)
}

// AutoParameterGenerator generates an object from a struct type. The fields in a struct can have tag.
// Tag name is "source". Its value format is "Source,Name".
//
// ex.
// type Example struct {
//     Start       int    `source:"Query,start"`
//     ContentType string `source:"Header,Content-Type"`
// }
type AutoParameterGenerator struct{}

func (g *AutoParameterGenerator) Source() definition.Source { return definition.Auto }
func (g *AutoParameterGenerator) Validate(name string, defaultValue interface{}, target reflect.Type) error {
	err := assignable(defaultValue, target)
	if err != nil {
		return err
	}
	if target.Kind() != reflect.Struct && !(target.Kind() == reflect.Ptr && target.Elem().Kind() == reflect.Struct) {
		return fmt.Errorf("%s should be a struct or a pointer to struct", target.String())
	}
	f := func(index []int, field reflect.StructField) error {
		source, name, err := g.split(field.Tag.Get("source"))
		if err != nil {
			return err
		}
		generator := ParameterGeneratorFor(definition.Source(source))
		if generator == nil {
			return fmt.Errorf("no parameter generator for source %s", source)
		}
		return generator.Validate(name, nil, field.Type)
	}
	if target.Kind() == reflect.Struct {
		err = g.enum([]int{}, target, f)
	} else {
		err = g.enum([]int{}, target.Elem(), f)
	}
	return err
}

func (g *AutoParameterGenerator) split(tag string) (source string, name string, err error) {
	result := strings.Split(tag, ",")
	if len(result) != 2 {
		return "", "", fmt.Errorf("filed tag %s is invalid", tag)
	}
	return result[0], result[1], nil
}

func (g *AutoParameterGenerator) Generate(ctx context.Context, vc ValueContainer, name string, target reflect.Type) (interface{}, error) {
	var result interface{}
	var value reflect.Value
	if target.Kind() == reflect.Struct {
		value = reflect.New(target).Elem()
		result = value.Interface()
	} else {
		value = reflect.New(target.Elem())
		result = value.Interface()
		value = value.Elem()
	}
	if err := g.generate(ctx, vc, value); err != nil {
		return nil, err
	}
	return result, nil
}

func (g *AutoParameterGenerator) generate(ctx context.Context, vc ValueContainer, value reflect.Value) error {
	f := func(index []int, field reflect.StructField) error {
		source, name, err := g.split(field.Tag.Get("source"))
		if err != nil {
			return err
		}
		generator := ParameterGeneratorFor(definition.Source(source))
		if generator == nil {
			return fmt.Errorf("no parameter generator for source %s", source)
		}
		ins, err := generator.Generate(ctx, vc, name, field.Type)
		if err != nil {
			return err
		}
		value.FieldByIndex(index).Set(reflect.ValueOf(ins))
		return nil
	}
	return g.enum([]int{}, value.Type(), f)
}

func (g *AutoParameterGenerator) enum(index []int, typ reflect.Type, f func(index []int, field reflect.StructField) error) error {
	var err error
	for i := 0; i < typ.NumField(); i++ {
		field := typ.Field(i)
		if field.Tag.Get("source") != "" {
			err = f(append(index, i), field)
		} else if field.Type.Kind() == reflect.Struct {
			err = g.enum(append(index, i), field.Type, f)
		}
		if err != nil {
			return err
		}
	}
	return nil
}
