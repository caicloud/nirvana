/*
Copyright 2017 Caicloud Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by set-gen. Do not edit it manually!

package cli

import (
	time "time"

	"github.com/spf13/cast"
	"github.com/spf13/pflag"
)

var _ Flag = BoolFlag{}

// BoolFlag is a flag of type bool
type BoolFlag struct {
	// Name as it appears on command line
	Name string
	// one-letter abbreviated flag
	Shorthand string
	// help message
	Usage string
	// specify whether the flag is persistent
	Persistent bool
	// used by cobra.Command bash autocomple code
	Annotations map[string][]string
	// If this flag is deprecated, this string is the new or now thing to use
	Deprecated string
	// If the shorthand of this flag is deprecated, this string is the new or now thing to use
	ShorthandDeprecated string
	// used by cobra.Command to allow flags to be hidden from help/usage text
	Hidden bool
	// bind the flag to env key, you can use AutomaticEnv to bind all flags to env automatically
	// if EnvKey is set, it will override the automatic generated env key
	EnvKey string
	// the default value
	DefValue bool
	// points to a variable in which to store the value of the flag
	Destination *bool
}

// IsPersistent specify whether the flag is persistent
func (f BoolFlag) IsPersistent() bool {
	return f.Persistent
}

// GetName returns the flag's name
func (f BoolFlag) GetName() string {
	return f.Name
}

// ApplyTo adds the flag to given FlagSet
func (f BoolFlag) ApplyTo(fs *pflag.FlagSet) error {

	if f.Destination == nil {
		f.Destination = new(bool)
	}

	realEnv, value := getEnv(f.Name, f.EnvKey, f.DefValue)
	defValue := cast.ToBool(value)

	// append env key to usage
	usage := appendEnvToUsage(f.Usage, realEnv)

	fs.BoolVarP(f.Destination, f.Name, f.Shorthand, defValue, usage)

	var err error

	if f.Deprecated != "" {
		err = fs.MarkDeprecated(f.Name, f.Deprecated)
		if err != nil {
			return err
		}
	}
	if f.ShorthandDeprecated != "" {
		err = fs.MarkShorthandDeprecated(f.Name, f.ShorthandDeprecated)
		if err != nil {
			return err
		}
	}
	if f.Hidden {
		err = fs.MarkHidden(f.Name)
		if err != nil {
			return err
		}
	}
	for key, values := range f.Annotations {
		err = fs.SetAnnotation(f.Name, key, values)
		if err != nil {
			return err
		}
	}

	return v.BindPFlag(f.Name, fs.Lookup(f.Name))
}

var _ Flag = DurationFlag{}

// DurationFlag is a flag of type time.Duration
type DurationFlag struct {
	// Name as it appears on command line
	Name string
	// one-letter abbreviated flag
	Shorthand string
	// help message
	Usage string
	// specify whether the flag is persistent
	Persistent bool
	// used by cobra.Command bash autocomple code
	Annotations map[string][]string
	// If this flag is deprecated, this string is the new or now thing to use
	Deprecated string
	// If the shorthand of this flag is deprecated, this string is the new or now thing to use
	ShorthandDeprecated string
	// used by cobra.Command to allow flags to be hidden from help/usage text
	Hidden bool
	// bind the flag to env key, you can use AutomaticEnv to bind all flags to env automatically
	// if EnvKey is set, it will override the automatic generated env key
	EnvKey string
	// the default value
	DefValue time.Duration
	// points to a variable in which to store the value of the flag
	Destination *time.Duration
}

// IsPersistent specify whether the flag is persistent
func (f DurationFlag) IsPersistent() bool {
	return f.Persistent
}

// GetName returns the flag's name
func (f DurationFlag) GetName() string {
	return f.Name
}

// ApplyTo adds the flag to given FlagSet
func (f DurationFlag) ApplyTo(fs *pflag.FlagSet) error {

	if f.Destination == nil {
		f.Destination = new(time.Duration)
	}

	realEnv, value := getEnv(f.Name, f.EnvKey, f.DefValue)
	defValue := cast.ToDuration(value)

	// append env key to usage
	usage := appendEnvToUsage(f.Usage, realEnv)

	fs.DurationVarP(f.Destination, f.Name, f.Shorthand, defValue, usage)

	var err error

	if f.Deprecated != "" {
		err = fs.MarkDeprecated(f.Name, f.Deprecated)
		if err != nil {
			return err
		}
	}
	if f.ShorthandDeprecated != "" {
		err = fs.MarkShorthandDeprecated(f.Name, f.ShorthandDeprecated)
		if err != nil {
			return err
		}
	}
	if f.Hidden {
		err = fs.MarkHidden(f.Name)
		if err != nil {
			return err
		}
	}
	for key, values := range f.Annotations {
		err = fs.SetAnnotation(f.Name, key, values)
		if err != nil {
			return err
		}
	}

	return v.BindPFlag(f.Name, fs.Lookup(f.Name))
}

var _ Flag = Float32Flag{}

// Float32Flag is a flag of type float32
type Float32Flag struct {
	// Name as it appears on command line
	Name string
	// one-letter abbreviated flag
	Shorthand string
	// help message
	Usage string
	// specify whether the flag is persistent
	Persistent bool
	// used by cobra.Command bash autocomple code
	Annotations map[string][]string
	// If this flag is deprecated, this string is the new or now thing to use
	Deprecated string
	// If the shorthand of this flag is deprecated, this string is the new or now thing to use
	ShorthandDeprecated string
	// used by cobra.Command to allow flags to be hidden from help/usage text
	Hidden bool
	// bind the flag to env key, you can use AutomaticEnv to bind all flags to env automatically
	// if EnvKey is set, it will override the automatic generated env key
	EnvKey string
	// the default value
	DefValue float32
	// points to a variable in which to store the value of the flag
	Destination *float32
}

// IsPersistent specify whether the flag is persistent
func (f Float32Flag) IsPersistent() bool {
	return f.Persistent
}

// GetName returns the flag's name
func (f Float32Flag) GetName() string {
	return f.Name
}

// ApplyTo adds the flag to given FlagSet
func (f Float32Flag) ApplyTo(fs *pflag.FlagSet) error {

	if f.Destination == nil {
		f.Destination = new(float32)
	}

	realEnv, value := getEnv(f.Name, f.EnvKey, f.DefValue)
	defValue := cast.ToFloat32(value)

	// append env key to usage
	usage := appendEnvToUsage(f.Usage, realEnv)

	fs.Float32VarP(f.Destination, f.Name, f.Shorthand, defValue, usage)

	var err error

	if f.Deprecated != "" {
		err = fs.MarkDeprecated(f.Name, f.Deprecated)
		if err != nil {
			return err
		}
	}
	if f.ShorthandDeprecated != "" {
		err = fs.MarkShorthandDeprecated(f.Name, f.ShorthandDeprecated)
		if err != nil {
			return err
		}
	}
	if f.Hidden {
		err = fs.MarkHidden(f.Name)
		if err != nil {
			return err
		}
	}
	for key, values := range f.Annotations {
		err = fs.SetAnnotation(f.Name, key, values)
		if err != nil {
			return err
		}
	}

	return v.BindPFlag(f.Name, fs.Lookup(f.Name))
}

var _ Flag = Float64Flag{}

// Float64Flag is a flag of type float64
type Float64Flag struct {
	// Name as it appears on command line
	Name string
	// one-letter abbreviated flag
	Shorthand string
	// help message
	Usage string
	// specify whether the flag is persistent
	Persistent bool
	// used by cobra.Command bash autocomple code
	Annotations map[string][]string
	// If this flag is deprecated, this string is the new or now thing to use
	Deprecated string
	// If the shorthand of this flag is deprecated, this string is the new or now thing to use
	ShorthandDeprecated string
	// used by cobra.Command to allow flags to be hidden from help/usage text
	Hidden bool
	// bind the flag to env key, you can use AutomaticEnv to bind all flags to env automatically
	// if EnvKey is set, it will override the automatic generated env key
	EnvKey string
	// the default value
	DefValue float64
	// points to a variable in which to store the value of the flag
	Destination *float64
}

// IsPersistent specify whether the flag is persistent
func (f Float64Flag) IsPersistent() bool {
	return f.Persistent
}

// GetName returns the flag's name
func (f Float64Flag) GetName() string {
	return f.Name
}

// ApplyTo adds the flag to given FlagSet
func (f Float64Flag) ApplyTo(fs *pflag.FlagSet) error {

	if f.Destination == nil {
		f.Destination = new(float64)
	}

	realEnv, value := getEnv(f.Name, f.EnvKey, f.DefValue)
	defValue := cast.ToFloat64(value)

	// append env key to usage
	usage := appendEnvToUsage(f.Usage, realEnv)

	fs.Float64VarP(f.Destination, f.Name, f.Shorthand, defValue, usage)

	var err error

	if f.Deprecated != "" {
		err = fs.MarkDeprecated(f.Name, f.Deprecated)
		if err != nil {
			return err
		}
	}
	if f.ShorthandDeprecated != "" {
		err = fs.MarkShorthandDeprecated(f.Name, f.ShorthandDeprecated)
		if err != nil {
			return err
		}
	}
	if f.Hidden {
		err = fs.MarkHidden(f.Name)
		if err != nil {
			return err
		}
	}
	for key, values := range f.Annotations {
		err = fs.SetAnnotation(f.Name, key, values)
		if err != nil {
			return err
		}
	}

	return v.BindPFlag(f.Name, fs.Lookup(f.Name))
}

var _ Flag = IntFlag{}

// IntFlag is a flag of type int
type IntFlag struct {
	// Name as it appears on command line
	Name string
	// one-letter abbreviated flag
	Shorthand string
	// help message
	Usage string
	// specify whether the flag is persistent
	Persistent bool
	// used by cobra.Command bash autocomple code
	Annotations map[string][]string
	// If this flag is deprecated, this string is the new or now thing to use
	Deprecated string
	// If the shorthand of this flag is deprecated, this string is the new or now thing to use
	ShorthandDeprecated string
	// used by cobra.Command to allow flags to be hidden from help/usage text
	Hidden bool
	// bind the flag to env key, you can use AutomaticEnv to bind all flags to env automatically
	// if EnvKey is set, it will override the automatic generated env key
	EnvKey string
	// the default value
	DefValue int
	// points to a variable in which to store the value of the flag
	Destination *int
}

// IsPersistent specify whether the flag is persistent
func (f IntFlag) IsPersistent() bool {
	return f.Persistent
}

// GetName returns the flag's name
func (f IntFlag) GetName() string {
	return f.Name
}

// ApplyTo adds the flag to given FlagSet
func (f IntFlag) ApplyTo(fs *pflag.FlagSet) error {

	if f.Destination == nil {
		f.Destination = new(int)
	}

	realEnv, value := getEnv(f.Name, f.EnvKey, f.DefValue)
	defValue := cast.ToInt(value)

	// append env key to usage
	usage := appendEnvToUsage(f.Usage, realEnv)

	fs.IntVarP(f.Destination, f.Name, f.Shorthand, defValue, usage)

	var err error

	if f.Deprecated != "" {
		err = fs.MarkDeprecated(f.Name, f.Deprecated)
		if err != nil {
			return err
		}
	}
	if f.ShorthandDeprecated != "" {
		err = fs.MarkShorthandDeprecated(f.Name, f.ShorthandDeprecated)
		if err != nil {
			return err
		}
	}
	if f.Hidden {
		err = fs.MarkHidden(f.Name)
		if err != nil {
			return err
		}
	}
	for key, values := range f.Annotations {
		err = fs.SetAnnotation(f.Name, key, values)
		if err != nil {
			return err
		}
	}

	return v.BindPFlag(f.Name, fs.Lookup(f.Name))
}

var _ Flag = Int32Flag{}

// Int32Flag is a flag of type int32
type Int32Flag struct {
	// Name as it appears on command line
	Name string
	// one-letter abbreviated flag
	Shorthand string
	// help message
	Usage string
	// specify whether the flag is persistent
	Persistent bool
	// used by cobra.Command bash autocomple code
	Annotations map[string][]string
	// If this flag is deprecated, this string is the new or now thing to use
	Deprecated string
	// If the shorthand of this flag is deprecated, this string is the new or now thing to use
	ShorthandDeprecated string
	// used by cobra.Command to allow flags to be hidden from help/usage text
	Hidden bool
	// bind the flag to env key, you can use AutomaticEnv to bind all flags to env automatically
	// if EnvKey is set, it will override the automatic generated env key
	EnvKey string
	// the default value
	DefValue int32
	// points to a variable in which to store the value of the flag
	Destination *int32
}

// IsPersistent specify whether the flag is persistent
func (f Int32Flag) IsPersistent() bool {
	return f.Persistent
}

// GetName returns the flag's name
func (f Int32Flag) GetName() string {
	return f.Name
}

// ApplyTo adds the flag to given FlagSet
func (f Int32Flag) ApplyTo(fs *pflag.FlagSet) error {

	if f.Destination == nil {
		f.Destination = new(int32)
	}

	realEnv, value := getEnv(f.Name, f.EnvKey, f.DefValue)
	defValue := cast.ToInt32(value)

	// append env key to usage
	usage := appendEnvToUsage(f.Usage, realEnv)

	fs.Int32VarP(f.Destination, f.Name, f.Shorthand, defValue, usage)

	var err error

	if f.Deprecated != "" {
		err = fs.MarkDeprecated(f.Name, f.Deprecated)
		if err != nil {
			return err
		}
	}
	if f.ShorthandDeprecated != "" {
		err = fs.MarkShorthandDeprecated(f.Name, f.ShorthandDeprecated)
		if err != nil {
			return err
		}
	}
	if f.Hidden {
		err = fs.MarkHidden(f.Name)
		if err != nil {
			return err
		}
	}
	for key, values := range f.Annotations {
		err = fs.SetAnnotation(f.Name, key, values)
		if err != nil {
			return err
		}
	}

	return v.BindPFlag(f.Name, fs.Lookup(f.Name))
}

var _ Flag = Int64Flag{}

// Int64Flag is a flag of type int64
type Int64Flag struct {
	// Name as it appears on command line
	Name string
	// one-letter abbreviated flag
	Shorthand string
	// help message
	Usage string
	// specify whether the flag is persistent
	Persistent bool
	// used by cobra.Command bash autocomple code
	Annotations map[string][]string
	// If this flag is deprecated, this string is the new or now thing to use
	Deprecated string
	// If the shorthand of this flag is deprecated, this string is the new or now thing to use
	ShorthandDeprecated string
	// used by cobra.Command to allow flags to be hidden from help/usage text
	Hidden bool
	// bind the flag to env key, you can use AutomaticEnv to bind all flags to env automatically
	// if EnvKey is set, it will override the automatic generated env key
	EnvKey string
	// the default value
	DefValue int64
	// points to a variable in which to store the value of the flag
	Destination *int64
}

// IsPersistent specify whether the flag is persistent
func (f Int64Flag) IsPersistent() bool {
	return f.Persistent
}

// GetName returns the flag's name
func (f Int64Flag) GetName() string {
	return f.Name
}

// ApplyTo adds the flag to given FlagSet
func (f Int64Flag) ApplyTo(fs *pflag.FlagSet) error {

	if f.Destination == nil {
		f.Destination = new(int64)
	}

	realEnv, value := getEnv(f.Name, f.EnvKey, f.DefValue)
	defValue := cast.ToInt64(value)

	// append env key to usage
	usage := appendEnvToUsage(f.Usage, realEnv)

	fs.Int64VarP(f.Destination, f.Name, f.Shorthand, defValue, usage)

	var err error

	if f.Deprecated != "" {
		err = fs.MarkDeprecated(f.Name, f.Deprecated)
		if err != nil {
			return err
		}
	}
	if f.ShorthandDeprecated != "" {
		err = fs.MarkShorthandDeprecated(f.Name, f.ShorthandDeprecated)
		if err != nil {
			return err
		}
	}
	if f.Hidden {
		err = fs.MarkHidden(f.Name)
		if err != nil {
			return err
		}
	}
	for key, values := range f.Annotations {
		err = fs.SetAnnotation(f.Name, key, values)
		if err != nil {
			return err
		}
	}

	return v.BindPFlag(f.Name, fs.Lookup(f.Name))
}

var _ Flag = StringFlag{}

// StringFlag is a flag of type string
type StringFlag struct {
	// Name as it appears on command line
	Name string
	// one-letter abbreviated flag
	Shorthand string
	// help message
	Usage string
	// specify whether the flag is persistent
	Persistent bool
	// used by cobra.Command bash autocomple code
	Annotations map[string][]string
	// If this flag is deprecated, this string is the new or now thing to use
	Deprecated string
	// If the shorthand of this flag is deprecated, this string is the new or now thing to use
	ShorthandDeprecated string
	// used by cobra.Command to allow flags to be hidden from help/usage text
	Hidden bool
	// bind the flag to env key, you can use AutomaticEnv to bind all flags to env automatically
	// if EnvKey is set, it will override the automatic generated env key
	EnvKey string
	// the default value
	DefValue string
	// points to a variable in which to store the value of the flag
	Destination *string
}

// IsPersistent specify whether the flag is persistent
func (f StringFlag) IsPersistent() bool {
	return f.Persistent
}

// GetName returns the flag's name
func (f StringFlag) GetName() string {
	return f.Name
}

// ApplyTo adds the flag to given FlagSet
func (f StringFlag) ApplyTo(fs *pflag.FlagSet) error {

	if f.Destination == nil {
		f.Destination = new(string)
	}

	realEnv, value := getEnv(f.Name, f.EnvKey, f.DefValue)
	defValue := cast.ToString(value)

	// append env key to usage
	usage := appendEnvToUsage(f.Usage, realEnv)

	fs.StringVarP(f.Destination, f.Name, f.Shorthand, defValue, usage)

	var err error

	if f.Deprecated != "" {
		err = fs.MarkDeprecated(f.Name, f.Deprecated)
		if err != nil {
			return err
		}
	}
	if f.ShorthandDeprecated != "" {
		err = fs.MarkShorthandDeprecated(f.Name, f.ShorthandDeprecated)
		if err != nil {
			return err
		}
	}
	if f.Hidden {
		err = fs.MarkHidden(f.Name)
		if err != nil {
			return err
		}
	}
	for key, values := range f.Annotations {
		err = fs.SetAnnotation(f.Name, key, values)
		if err != nil {
			return err
		}
	}

	return v.BindPFlag(f.Name, fs.Lookup(f.Name))
}

var _ Flag = StringSliceFlag{}

// StringSliceFlag is a flag of type []string
type StringSliceFlag struct {
	// Name as it appears on command line
	Name string
	// one-letter abbreviated flag
	Shorthand string
	// help message
	Usage string
	// specify whether the flag is persistent
	Persistent bool
	// used by cobra.Command bash autocomple code
	Annotations map[string][]string
	// If this flag is deprecated, this string is the new or now thing to use
	Deprecated string
	// If the shorthand of this flag is deprecated, this string is the new or now thing to use
	ShorthandDeprecated string
	// used by cobra.Command to allow flags to be hidden from help/usage text
	Hidden bool
	// bind the flag to env key, you can use AutomaticEnv to bind all flags to env automatically
	// if EnvKey is set, it will override the automatic generated env key
	EnvKey string
	// the default value
	DefValue []string
	// points to a variable in which to store the value of the flag
	Destination *[]string
}

// IsPersistent specify whether the flag is persistent
func (f StringSliceFlag) IsPersistent() bool {
	return f.Persistent
}

// GetName returns the flag's name
func (f StringSliceFlag) GetName() string {
	return f.Name
}

// ApplyTo adds the flag to given FlagSet
func (f StringSliceFlag) ApplyTo(fs *pflag.FlagSet) error {

	if f.Destination == nil {
		f.Destination = new([]string)
	}

	realEnv, value := getEnv(f.Name, f.EnvKey, f.DefValue)
	defValue := cast.ToStringSlice(value)

	// append env key to usage
	usage := appendEnvToUsage(f.Usage, realEnv)

	fs.StringSliceVarP(f.Destination, f.Name, f.Shorthand, defValue, usage)

	var err error

	if f.Deprecated != "" {
		err = fs.MarkDeprecated(f.Name, f.Deprecated)
		if err != nil {
			return err
		}
	}
	if f.ShorthandDeprecated != "" {
		err = fs.MarkShorthandDeprecated(f.Name, f.ShorthandDeprecated)
		if err != nil {
			return err
		}
	}
	if f.Hidden {
		err = fs.MarkHidden(f.Name)
		if err != nil {
			return err
		}
	}
	for key, values := range f.Annotations {
		err = fs.SetAnnotation(f.Name, key, values)
		if err != nil {
			return err
		}
	}

	return v.BindPFlag(f.Name, fs.Lookup(f.Name))
}

var _ Flag = UintFlag{}

// UintFlag is a flag of type uint
type UintFlag struct {
	// Name as it appears on command line
	Name string
	// one-letter abbreviated flag
	Shorthand string
	// help message
	Usage string
	// specify whether the flag is persistent
	Persistent bool
	// used by cobra.Command bash autocomple code
	Annotations map[string][]string
	// If this flag is deprecated, this string is the new or now thing to use
	Deprecated string
	// If the shorthand of this flag is deprecated, this string is the new or now thing to use
	ShorthandDeprecated string
	// used by cobra.Command to allow flags to be hidden from help/usage text
	Hidden bool
	// bind the flag to env key, you can use AutomaticEnv to bind all flags to env automatically
	// if EnvKey is set, it will override the automatic generated env key
	EnvKey string
	// the default value
	DefValue uint
	// points to a variable in which to store the value of the flag
	Destination *uint
}

// IsPersistent specify whether the flag is persistent
func (f UintFlag) IsPersistent() bool {
	return f.Persistent
}

// GetName returns the flag's name
func (f UintFlag) GetName() string {
	return f.Name
}

// ApplyTo adds the flag to given FlagSet
func (f UintFlag) ApplyTo(fs *pflag.FlagSet) error {

	if f.Destination == nil {
		f.Destination = new(uint)
	}

	realEnv, value := getEnv(f.Name, f.EnvKey, f.DefValue)
	defValue := cast.ToUint(value)

	// append env key to usage
	usage := appendEnvToUsage(f.Usage, realEnv)

	fs.UintVarP(f.Destination, f.Name, f.Shorthand, defValue, usage)

	var err error

	if f.Deprecated != "" {
		err = fs.MarkDeprecated(f.Name, f.Deprecated)
		if err != nil {
			return err
		}
	}
	if f.ShorthandDeprecated != "" {
		err = fs.MarkShorthandDeprecated(f.Name, f.ShorthandDeprecated)
		if err != nil {
			return err
		}
	}
	if f.Hidden {
		err = fs.MarkHidden(f.Name)
		if err != nil {
			return err
		}
	}
	for key, values := range f.Annotations {
		err = fs.SetAnnotation(f.Name, key, values)
		if err != nil {
			return err
		}
	}

	return v.BindPFlag(f.Name, fs.Lookup(f.Name))
}

var _ Flag = Uint32Flag{}

// Uint32Flag is a flag of type uint32
type Uint32Flag struct {
	// Name as it appears on command line
	Name string
	// one-letter abbreviated flag
	Shorthand string
	// help message
	Usage string
	// specify whether the flag is persistent
	Persistent bool
	// used by cobra.Command bash autocomple code
	Annotations map[string][]string
	// If this flag is deprecated, this string is the new or now thing to use
	Deprecated string
	// If the shorthand of this flag is deprecated, this string is the new or now thing to use
	ShorthandDeprecated string
	// used by cobra.Command to allow flags to be hidden from help/usage text
	Hidden bool
	// bind the flag to env key, you can use AutomaticEnv to bind all flags to env automatically
	// if EnvKey is set, it will override the automatic generated env key
	EnvKey string
	// the default value
	DefValue uint32
	// points to a variable in which to store the value of the flag
	Destination *uint32
}

// IsPersistent specify whether the flag is persistent
func (f Uint32Flag) IsPersistent() bool {
	return f.Persistent
}

// GetName returns the flag's name
func (f Uint32Flag) GetName() string {
	return f.Name
}

// ApplyTo adds the flag to given FlagSet
func (f Uint32Flag) ApplyTo(fs *pflag.FlagSet) error {

	if f.Destination == nil {
		f.Destination = new(uint32)
	}

	realEnv, value := getEnv(f.Name, f.EnvKey, f.DefValue)
	defValue := cast.ToUint32(value)

	// append env key to usage
	usage := appendEnvToUsage(f.Usage, realEnv)

	fs.Uint32VarP(f.Destination, f.Name, f.Shorthand, defValue, usage)

	var err error

	if f.Deprecated != "" {
		err = fs.MarkDeprecated(f.Name, f.Deprecated)
		if err != nil {
			return err
		}
	}
	if f.ShorthandDeprecated != "" {
		err = fs.MarkShorthandDeprecated(f.Name, f.ShorthandDeprecated)
		if err != nil {
			return err
		}
	}
	if f.Hidden {
		err = fs.MarkHidden(f.Name)
		if err != nil {
			return err
		}
	}
	for key, values := range f.Annotations {
		err = fs.SetAnnotation(f.Name, key, values)
		if err != nil {
			return err
		}
	}

	return v.BindPFlag(f.Name, fs.Lookup(f.Name))
}

var _ Flag = Uint64Flag{}

// Uint64Flag is a flag of type uint64
type Uint64Flag struct {
	// Name as it appears on command line
	Name string
	// one-letter abbreviated flag
	Shorthand string
	// help message
	Usage string
	// specify whether the flag is persistent
	Persistent bool
	// used by cobra.Command bash autocomple code
	Annotations map[string][]string
	// If this flag is deprecated, this string is the new or now thing to use
	Deprecated string
	// If the shorthand of this flag is deprecated, this string is the new or now thing to use
	ShorthandDeprecated string
	// used by cobra.Command to allow flags to be hidden from help/usage text
	Hidden bool
	// bind the flag to env key, you can use AutomaticEnv to bind all flags to env automatically
	// if EnvKey is set, it will override the automatic generated env key
	EnvKey string
	// the default value
	DefValue uint64
	// points to a variable in which to store the value of the flag
	Destination *uint64
}

// IsPersistent specify whether the flag is persistent
func (f Uint64Flag) IsPersistent() bool {
	return f.Persistent
}

// GetName returns the flag's name
func (f Uint64Flag) GetName() string {
	return f.Name
}

// ApplyTo adds the flag to given FlagSet
func (f Uint64Flag) ApplyTo(fs *pflag.FlagSet) error {

	if f.Destination == nil {
		f.Destination = new(uint64)
	}

	realEnv, value := getEnv(f.Name, f.EnvKey, f.DefValue)
	defValue := cast.ToUint64(value)

	// append env key to usage
	usage := appendEnvToUsage(f.Usage, realEnv)

	fs.Uint64VarP(f.Destination, f.Name, f.Shorthand, defValue, usage)

	var err error

	if f.Deprecated != "" {
		err = fs.MarkDeprecated(f.Name, f.Deprecated)
		if err != nil {
			return err
		}
	}
	if f.ShorthandDeprecated != "" {
		err = fs.MarkShorthandDeprecated(f.Name, f.ShorthandDeprecated)
		if err != nil {
			return err
		}
	}
	if f.Hidden {
		err = fs.MarkHidden(f.Name)
		if err != nil {
			return err
		}
	}
	for key, values := range f.Annotations {
		err = fs.SetAnnotation(f.Name, key, values)
		if err != nil {
			return err
		}
	}

	return v.BindPFlag(f.Name, fs.Lookup(f.Name))
}
