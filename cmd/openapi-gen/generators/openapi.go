/*
Copyright 2017 Caicloud Authors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package generators

import (
	"bytes"
	"fmt"
	"io"
	"path/filepath"
	"sort"
	"strings"

	"github.com/caicloud/nirvana/utils/openapi/common"
	"github.com/golang/glog"
	"k8s.io/gengo/args"
	"k8s.io/gengo/generator"
	"k8s.io/gengo/namer"
	"k8s.io/gengo/types"
)

// NameSystems returns the name systems used by generators
func NameSystems() namer.NameSystems {
	return namer.NameSystems{
		"raw": namer.NewRawNamer("", nil),
	}
}

// DefaultNameSystem returns the name of default name system
// used by generators
func DefaultNameSystem() string {
	return "raw"
}

const (
	warningInfo = `
// This file was autogenerated by openapi-gen. Do not edit it manually!

`
)

// Packages returns packages which will be processed by generators
func Packages(ctx *generator.Context, arguments *args.GeneratorArgs) generator.Packages {
	boilerplate, err := arguments.LoadGoBoilerplate()
	if err != nil {
		glog.Fatalf("Failed loading boilerplate: %v", err)
	}

	header := append([]byte(fmt.Sprintf("// +build !%s\n\n", arguments.GeneratedBuildTag)), boilerplate...)
	header = append(header, []byte(warningInfo)...)

	outputPath := arguments.OutputPackagePath
	if err := ctx.AddDir(outputPath); err != nil {
		glog.Fatalf("Failed to load output package: %v", err)
	}

	pkg := ctx.Universe[outputPath]
	if pkg == nil {
		glog.Fatalf("Got nil output package: %v", err)
	}

	return generator.Packages{
		&generator.DefaultPackage{
			PackageName: strings.Split(filepath.Base(pkg.Path), ".")[0],
			PackagePath: outputPath,
			HeaderText:  header,
			GeneratorFunc: func(ctx *generator.Context) (generators []generator.Generator) {
				return []generator.Generator{
					NewOpenAPIGen(arguments.OutputFileBaseName, pkg),
				}
			},
			FilterFunc: func(ctx *generator.Context, t *types.Type) bool {
				p := ctx.Universe.Package(t.Name.Package)
				if hasOpenAPITagValue(p.Comments, tagValueTrue) {
					return !hasOpenAPITagValue(t.CommentLines, tagValueFalse)
				}
				if hasOpenAPITagValue(t.CommentLines, tagValueTrue) {
					return true
				}
				return false
			},
		},
	}
}

const (
	specPackagePath          = "github.com/go-openapi/spec"
	openAPICommonPackagePath = "github.com/caicloud/nirvana/utils/openapi/common"
)

// NewOpenAPIGen returns an openapi generator
func NewOpenAPIGen(name string, target *types.Package) generator.Generator {
	return &openAPIGen{
		DefaultGen: generator.DefaultGen{
			OptionalName: name,
		},
		target:  target,
		imports: generator.NewImportTracker(),
	}
}

type openAPIGen struct {
	generator.DefaultGen
	target  *types.Package
	imports namer.ImportTracker
}

func (g *openAPIGen) Namers(ctx *generator.Context) namer.NameSystems {
	return namer.NameSystems{
		"raw": namer.NewRawNamer(g.target.Path, g.imports),
	}
}

func (g *openAPIGen) Imports(ctx *generator.Context) []string {
	importLines := []string{}
	importLines = append(importLines, g.imports.ImportLines()...)
	return importLines
}

func (g *openAPIGen) Init(ctx *generator.Context, w io.Writer) error {
	const (
		header = `
// GetOpenAPIDefinitions defines function to get OpenAPI definition
func GetOpenAPIDefinitions(ref $.ReferenceCallback|raw$) map[string]$.OpenAPIDefinition|raw$ {
	return map[string]$.OpenAPIDefinition|raw${
`
	)
	sw := generator.NewSnippetWriter(w, ctx, "$", "$")
	sw.Do(header, argsFromType(nil))
	return sw.Error()
}

func (g *openAPIGen) Finalize(c *generator.Context, w io.Writer) error {
	const (
		footer = `
	}
}
`
	)
	sw := generator.NewSnippetWriter(w, c, "$", "$")
	sw.Do(footer, nil)
	return sw.Error()
}

func argsFromType(t *types.Type) generator.Args {
	return generator.Args{
		"type":              t,
		"ReferenceCallback": types.Ref(openAPICommonPackagePath, "ReferenceCallback"),
		"OpenAPIDefinition": types.Ref(openAPICommonPackagePath, "OpenAPIDefinition"),
		"Schema":            types.Ref(specPackagePath, "Schema"),
		"SchemaOrBool":      types.Ref(specPackagePath, "SchemaOrBool"),
		"SchemaOrArray":     types.Ref(specPackagePath, "SchemaOrArray"),
		"SchemaProps":       types.Ref(specPackagePath, "SchemaProps"),
	}
}

func (g *openAPIGen) GenerateType(ctx *generator.Context, t *types.Type, w io.Writer) error {
	glog.Infof("generating for type %v", t)
	sw := generator.NewSnippetWriter(w, ctx, "$", "$")
	if err := newOpenAPITypeWriter(sw).generate(t); err != nil {
		return err
	}
	return sw.Error()
}

func newOpenAPITypeWriter(sw *generator.SnippetWriter) *openAPITypeWriter {
	return &openAPITypeWriter{
		SnippetWriter: sw,
		refTypes:      map[string]*types.Type{},
	}
}

type openAPITypeWriter struct {
	*generator.SnippetWriter

	refTypes map[string]*types.Type
	required []string
}

func (sw *openAPITypeWriter) generateSimpleSchema(t string, f string) {
	sw.Do(`Type: []string{"$.$"},`+"\n", t)
	sw.Do(`Format: "$.$",`+"\n", f)
}

func (sw *openAPITypeWriter) generateRefSchema(t *types.Type) {
	sw.refTypes[t.Name.String()] = t
	sw.Do(`Ref: ref("$.$"),`+"\n", t.Name.String())
}

func (sw *openAPITypeWriter) generateElemSchema(t *types.Type) error {
	otype, oformat := common.GetOpenAPITypeFormat(t.Name.String())
	// a simple schema
	if otype != "" {
		sw.generateSimpleSchema(otype, oformat)
		return nil
	}
	switch t.Kind {
	case types.Struct, types.Interface:
		sw.generateRefSchema(t)
	case types.Slice, types.Array:
		return sw.generateSliceSchema(t)
	case types.Map:
		return sw.generateMapSchema(t)
	default:
		return fmt.Errorf("can't generate slice elem for kind %v", t.Kind)
	}
	return nil
}

func (sw *openAPITypeWriter) generateSliceSchema(t *types.Type) error {
	const (
		header, footer = `Type: []string{"array"},
			Items: &$.SchemaOrArray|raw${
				Schema: &$.Schema|raw${
					SchemaProps: $.SchemaProps|raw${
			`, `	},
				},
			},
			`
	)

	elemType := resolveAliasAndPtrType(t.Elem)

	sw.Do(header, argsFromType(t))
	if err := sw.generateElemSchema(elemType); err != nil {
		return err
	}
	sw.Do(footer, argsFromType(t))
	return nil
}

func (sw *openAPITypeWriter) generateMapSchema(t *types.Type) error {
	const (
		header, footer = `Type: []string{"object"},
			AdditionalProperties: &$.SchemaOrBool|raw${
				Schema: &$.Schema|raw${
					SchemaProps: $.SchemaProps|raw${
			`, `	},
				},
			},
			`
	)

	// key MUST be string or can be converted to string, e.g. int
	// just ignore type of map key
	elemType := resolveAliasAndPtrType(t.Elem)

	sw.Do(header, argsFromType(t))
	if err := sw.generateElemSchema(elemType); err != nil {
		return err
	}
	sw.Do(footer, argsFromType(t))
	return nil
}

func (sw *openAPITypeWriter) generateDescription(CommentLines []string) {
	var buffer bytes.Buffer
	delPrevChar := func() {
		if buffer.Len() > 0 {
			buffer.Truncate(buffer.Len() - 1) // Delete the last " " or "\n"
		}
	}

	for _, line := range CommentLines {
		// Ignore all lines after ---
		if line == "---" {
			break
		}
		line = strings.TrimRight(line, " ")
		leading := strings.TrimLeft(line, " ")
		switch {
		// Keep paragraphs
		case len(line) == 0:
			delPrevChar()
			buffer.WriteString("\n\n")
		// Ignore one line TODOs
		case strings.HasPrefix(leading, "TODO"):
		// Ignore tag marker
		case strings.HasPrefix(leading, "+"):
		default:
			if strings.HasPrefix(line, " ") || strings.HasPrefix(line, "\t") {
				delPrevChar()
				// Replace it with newline. This is useful when we have a line with: "Example:\n\tJSON-someting..."
				line = "\n" + line + "\n"
			} else {
				line += " "
			}
			buffer.WriteString(line)
		}
	}

	postDoc := strings.TrimRight(buffer.String(), "\n")
	// replace user's \" to "
	postDoc = strings.Replace(postDoc, "\\\"", "\"", -1)
	// Escape "
	postDoc = strings.Replace(postDoc, "\"", "\\\"", -1)
	postDoc = strings.Replace(postDoc, "\n", "\\n", -1)
	postDoc = strings.Replace(postDoc, "\t", "\\t", -1)
	postDoc = strings.Trim(postDoc, " ")
	if postDoc != "" {
		sw.Do(`Description: "$.$",`+"\n", postDoc)
	}
}

func (sw *openAPITypeWriter) generateProperty(m *types.Member) error {
	const (
		header, footer = `"$.name$": {
				SchemaProps: $.SchemaProps|raw${
			`, `},
			},
			`
	)
	name := getReferableName(m)
	if name == "" {
		return nil
	}

	t := resolveAliasAndPtrType(m.Type)

	a := argsFromType(t)
	a["name"] = name

	sw.Do(header, a)
	sw.generateDescription(m.CommentLines)
	if err := sw.generateElemSchema(t); err != nil {
		return err
	}
	sw.Do(footer, a)
	return nil
}

func (sw *openAPITypeWriter) generatePropertyElem(t *types.Type) error {
	for _, m := range t.Members {
		if hasOpenAPITagValue(m.CommentLines, tagValueFalse) {
			continue
		}
		if isInline(&m) {
			if err := sw.generatePropertyElem(m.Type); err != nil {
				return err
			}

		} else {
			name := getReferableName(&m)
			if name == "" {
				continue
			}
			if !hasOptionalTag(&m) {
				sw.required = append(sw.required, name)
			}
			if err := sw.generateProperty(&m); err != nil {
				glog.Errorf("Error when generating: %v, %v\n", name, m)
				return err
			}
		}
	}
	return nil
}

func (sw *openAPITypeWriter) generateProperties(t *types.Type) error {
	const (
		header, footer = `Properties: map[string]$.Schema|raw${
			`, `},
			`
	)

	sw.Do(header, argsFromType(t))
	if err := sw.generatePropertyElem(t); err != nil {
		return err
	}
	sw.Do(footer, nil)
	return nil
}

func (sw *openAPITypeWriter) generateRequired(required []string) {
	if len(required) > 0 {
		sw.Do(`Required: []string{
			"$.$",
		},`+"\n", strings.Join(required, "\",\n\""))
	}
}

func (sw *openAPITypeWriter) generateSchema(t *types.Type) error {
	const (
		header, footer = `Schema: $.Schema|raw${
				SchemaProps: $.SchemaProps|raw${
			`, `},
			},
			`
	)

	sw.Do(header, argsFromType(t))
	sw.generateDescription(t.CommentLines)
	if err := sw.generateProperties(t); err != nil {
		return err
	}
	sw.generateRequired(sw.required)
	sw.Do(footer, nil)
	return nil
}

func (sw *openAPITypeWriter) generateDependency() {
	keys := []string{}
	for k, v := range sw.refTypes {
		if t, _ := common.GetOpenAPITypeFormat(v.String()); t != "" {
			// This is a known type, we do not need a reference to it
			// Will eliminate special case of time.Time
			continue
		}

		keys = append(keys, k)
	}
	if len(keys) == 0 {
		return
	}
	sort.Strings(keys)
	sw.Do(`Dependencies: []string{
		"$.$",
	},`+"\n", strings.Join(keys, "\",\n\""))
}

func (sw *openAPITypeWriter) generate(t *types.Type) error {
	const (
		header, footer = `"$.$": {
			`, `},
			`
	)

	switch t.Kind {
	case types.Struct:
		sw.Do(header, t.Name)
		if err := sw.generateSchema(t); err != nil {
			return err
		}
		sw.generateDependency()
		sw.Do(footer, nil)
	}
	return nil
}
